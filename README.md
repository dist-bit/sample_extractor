# Gu√≠a Completa: Cliente API de Nebuia para Procesamiento de Documentos

## √çndice
1. [Introducci√≥n](#introducci√≥n)
2. [¬øQu√© hace este c√≥digo?](#qu√©-hace-este-c√≥digo)
3. [Estructura del C√≥digo](#estructura-del-c√≥digo)
4. [Componentes Principales](#componentes-principales)
   - [Clase `NebuiaCredentials`](#clase-nebuiacredentials)
   - [Clase `NebuiaClient`](#clase-nebuiaclient)
   - [Clase `NebuiaHandler`](#clase-nebuiahandler)
5. [Flujo de Trabajo](#flujo-de-trabajo)
6. [Funciones Clave](#funciones-clave)
7. [Registro de Comandos cURL](#registro-de-comandos-curl)
8. [Ejemplos de Uso](#ejemplos-de-uso)
9. [Ejemplos Detallados de M√©todos Principales](#ejemplos-detallados-de-m√©todos-principales)
10. [Ejemplos de Respuestas de la API](#ejemplos-de-respuestas-de-la-api)
11. [Soluci√≥n de Problemas](#soluci√≥n-de-problemas)
12. [Glosario](#glosario)

## Introducci√≥n

Este c√≥digo es un cliente para interactuar con la API de Nebuia, un servicio que permite procesar, verificar y extraer informaci√≥n de documentos. El cliente est√° dise√±ado para facilitar tareas como:

- Subir documentos PDF a la plataforma Nebuia
- Verificar tipos de documentos
- Procesar documentos para extraer informaci√≥n
- Monitorear el estado de procesamiento
- Obtener resultados estructurados

El c√≥digo est√° escrito en Python y utiliza la biblioteca `requests` para manejar las comunicaciones HTTP con la API de Nebuia.

## ¬øQu√© hace este c√≥digo?

En t√©rminos simples, este c√≥digo permite:

1. **Cargar documentos**: Enviar archivos PDF a la plataforma Nebuia
2. **Verificar documentos**: Comprobar que los documentos son del tipo esperado
3. **Procesar documentos**: Extraer informaci√≥n relevante de los documentos
4. **Monitorear**: Seguir el progreso del procesamiento
5. **Obtener resultados**: Recuperar la informaci√≥n extra√≠da de forma estructurada

Todo esto se hace mediante llamadas a la API de Nebuia, que es un servicio externo especializado en procesamiento de documentos.

## Estructura del C√≥digo

El c√≥digo est√° organizado en dos archivos principales:

1. **nebuia_client.py**: Contiene las clases base y la l√≥gica de comunicaci√≥n con la API
   - `NebuiaCredentials`: Gestiona las credenciales de autenticaci√≥n
   - `NebuiaClient`: Maneja todas las comunicaciones con la API de Nebuia
   - Clases de errores personalizados

2. **nebuia_handler.py**: Proporciona una capa de abstracci√≥n m√°s amigable
   - `NebuiaHandler`: Facilita operaciones de alto nivel y mejora la experiencia de usuario

## Componentes Principales

### Clase `NebuiaCredentials`

Esta clase almacena y valida las credenciales necesarias para acceder a la API de Nebuia:

- `client_id`: Identificador √∫nico del cliente en Nebuia
- `api_key`: Clave de API para autenticaci√≥n
- `api_secret`: Secreto de API para autenticaci√≥n

La clase verifica que todas las credenciales est√©n presentes y sean v√°lidas. Si falta alguna, lanzar√° un error ValueError con un mensaje claro.

### Clase `NebuiaClient`

Esta es la clase principal que maneja todas las comunicaciones con la API de Nebuia. Sus caracter√≠sticas incluyen:

- **Gesti√≥n de autenticaci√≥n**: Usa las credenciales para autenticar todas las peticiones
- **Operaciones CRUD**: Crear, leer, actualizar y eliminar recursos en Nebuia
- **Manejo de errores**: Captura y procesa errores de la API
- **Registro de comandos cURL**: Guarda equivalentes cURL de cada petici√≥n HTTP para depuraci√≥n
- **Operaciones as√≠ncronas**: Permite esperar a que se completen operaciones de larga duraci√≥n

Las funciones principales incluyen:

- `create_record`: Crea un nuevo registro para asociar documentos
- `upload_document`: Sube un documento PDF a un registro
- `verify_document_type`: Verifica que un documento sea del tipo esperado
- `create_processing_job`: Inicia el procesamiento de los documentos
- `wait_for_record_completion`: Espera a que se complete el procesamiento

### Clase `NebuiaHandler`

Esta clase proporciona una interfaz m√°s amigable y de alto nivel para trabajar con la API de Nebuia:

- Simplifica flujos de trabajo complejos
- Mejora el manejo de errores y la retroalimentaci√≥n
- Proporciona informaci√≥n visual sobre el progreso
- Extrae informaci√≥n relevante de los resultados

## Flujo de Trabajo Detallado

El procesamiento de documentos sigue un flujo completo que es importante entender. A continuaci√≥n se detalla paso a paso:

### 1. Inicializaci√≥n del Cliente

```python
handler = NebuiaHandler(client_id="...", api_key="...", api_secret="...")
```

Al inicializar el cliente, se configuran:
- Las credenciales de autenticaci√≥n
- El registro (logging)
- La sesi√≥n HTTP para comunicaci√≥n con la API

### 2. Definir Documentos a Procesar

```python
documents = {
    "acta_constitutiva": "./documentos/acta.pdf",
    "actas_de_asamblea": "./documentos/asamblea.pdf"
}
```

En este paso:
- Se especifican las rutas a los archivos PDF
- Se asocia cada documento con un tipo espec√≠fico seg√∫n la configuraci√≥n de Nebuia

### 3. Validaci√≥n de Documentos

Internamente, el m√©todo `process_documents` valida cada documento:
- Verifica que el archivo exista en el sistema
- Comprueba que sea un archivo PDF v√°lido
- Filtra cualquier documento inv√°lido

### 4. Creaci√≥n del Registro (Record)

Se crea un nuevo registro en Nebuia mediante:
```python
record_response = client.create_record(config_name)
```

Esto devuelve:
- `id`: Identificador √∫nico del registro
- Otros metadatos del registro

### 5. Carga de Documentos

Para cada documento validado:
```python
upload_response = client.upload_document(record_id, file_path, doc_type)
```

Este paso:
- Sube el archivo PDF al servidor de Nebuia
- Asocia el documento con el tipo especificado
- Obtiene un identificador √∫nico para cada documento

### 6. Espera por Embedding

El sistema espera a que Nebuia procese inicialmente los documentos:
```python
embedding_success = self._wait_for_embedding(document_ids, interval, timeout)
```

Durante este proceso:
- Se consulta peri√≥dicamente el estado de cada documento
- Se muestra el progreso en la consola
- Se espera hasta que todos los documentos est√°n en estado "complete"

### 7. Verificaci√≥n de Tipos de Documento

Una vez procesados los documentos, se verifica que sean del tipo correcto:
```python
verification_results, verification_passed = self._verify_all_documents(record_id, document_ids)
```

En este paso cr√≠tico:
- Se verifica cada documento contra su tipo esperado
- Se muestran los resultados de verificaci√≥n
- Se determina si todos los documentos son v√°lidos para continuar

### 8. Creaci√≥n del Trabajo de Procesamiento

Si la verificaci√≥n es exitosa y auto_process=True:
```python
job_response = self.client.create_processing_job(record_id)
```

Esto:
- Inicia el procesamiento profundo de los documentos
- Crea un trabajo as√≠ncrono en Nebuia
- Devuelve un identificador de trabajo

### 9. Espera por Finalizaci√≥n (Opcional)

Si wait_for_completion=True:
```python
completed_record = self.client.wait_for_record_completion(record_id, timeout, status_callback)
```

Durante este tiempo:
- Se monitorea peri√≥dicamente el estado del registro
- Se muestra el progreso mediante callbacks
- Se espera hasta la finalizaci√≥n o timeout

### 10. Obtenci√≥n de Resultados

Finalmente:
```python
extracted_info = handler.extract_document_entities(result)
```

Esto:
- Extrae la informaci√≥n estructurada de los documentos
- Organiza los datos por tipo de documento
- Limpia los datos para facilitar su uso

## Tipos de Respuesta en la Verificaci√≥n de Documentos

La verificaci√≥n de tipos de documentos es un paso crucial. Cuando se llama a `verify_document_type`, se pueden obtener diferentes tipos de respuesta:

### Respuesta Exitosa

Si el documento coincide con el tipo esperado:

```json
{
    "status": true
}
```

### Respuesta Fallida

Si el documento no coincide con el tipo esperado:

```json
{
    "status": false,
    "points": [
        "El documento no contiene las secciones esperadas para un acta constitutiva",
        "No se encontr√≥ la secci√≥n de estatutos",
        "No se identificaron las firmas requeridas"
    ],
    "type_document_found": "otro_tipo_documento"
}
```

Donde:
- `status`: Indica si la verificaci√≥n fue exitosa (false en este caso)
- `points`: Lista de razones por las que fall√≥ la verificaci√≥n
- `type_document_found`: El tipo de documento que Nebuia cree que es realmente

### Visualizaci√≥n de los Resultados

El m√©todo `_display_verification_points` muestra estos resultados de forma legible:

```
‚úÖ VERIFICACI√ìN EXITOSA ‚úÖ
============================================================
üìÑ Tipo de documento: acta_constitutiva

üîç CRITERIOS DE VERIFICACI√ìN:
------------------------------------------------------------
  01. El documento contiene todas las secciones requeridas
  02. Se identificaron estatutos correctamente
  03. Firmas validadas correctamente
------------------------------------------------------------
```

O en caso de fallo:

```
‚ùå VERIFICACI√ìN FALLIDA ‚ùå
============================================================
üìÑ Tipo de documento: otro_tipo_documento

üîç CRITERIOS DE VERIFICACI√ìN:
------------------------------------------------------------
  01. El documento no contiene las secciones esperadas para un acta constitutiva
  02. No se encontr√≥ la secci√≥n de estatutos
  03. No se identificaron las firmas requeridas
------------------------------------------------------------
```

### Implicaciones de la Verificaci√≥n

- Si **todos** los documentos pasan la verificaci√≥n, se crea autom√°ticamente un trabajo de procesamiento
- Si **alg√∫n** documento falla la verificaci√≥n, no se crea el trabajo (a menos que auto_process=True)
- Los resultados de verificaci√≥n se a√±aden a los resultados finales en `verification_results`

## Funciones Clave

### En `NebuiaClient`

#### `_make_request`
Esta funci√≥n es la base de todas las comunicaciones con la API:
- Construye la URL completa
- A√±ade los encabezados de autenticaci√≥n
- Registra el comando cURL equivalente
- Maneja errores de la API y de red
- Procesa y devuelve la respuesta JSON

#### `upload_document`
Permite subir un documento PDF a un registro:
- Verifica que el archivo exista y sea un PDF
- Prepara los datos del formulario multipart
- Gestiona el cierre del archivo despu√©s de la carga

#### `wait_for_record_completion`
Espera a que se complete el procesamiento de un registro:
- Consulta peri√≥dicamente el estado del registro
- Invoca callbacks para informar del progreso
- Maneja tiempos de espera y errores

### En `NebuiaHandler`

#### `process_documents`
Esta es la funci√≥n principal que orquesta todo el proceso:
1. Valida los documentos
2. Crea un registro y sube los documentos
3. Espera a que los documentos sean procesados por el motor de embeddings
4. Verifica los tipos de documentos
5. Crea un trabajo de procesamiento
6. Espera a que se complete el procesamiento
7. Devuelve los resultados

#### `_verify_all_documents`
Verifica que todos los documentos sean del tipo esperado:
- Llama a la API para verificar cada documento
- Muestra los resultados de verificaci√≥n
- Determina si todos los documentos pasaron la verificaci√≥n

#### `extract_document_entities`
Extrae informaci√≥n relevante de los resultados:
- Procesa cada documento en los resultados
- Extrae las estructuras de entidades
- Limpia los datos para facilitar su uso

## Registro de Comandos cURL

Una caracter√≠stica interesante de este c√≥digo es el registro de comandos cURL. Para cada petici√≥n a la API, el c√≥digo:

1. Convierte la petici√≥n HTTP a su equivalente en cURL
2. Registra el comando en un archivo de registro
3. Opcionalmente lo muestra en la consola

Esto es √∫til para:
- Depurar problemas de comunicaci√≥n con la API
- Reproducir peticiones fuera del c√≥digo
- Compartir ejemplos de uso de la API

El registro incluye detalles como:
- Nombre de la operaci√≥n
- Marca de tiempo
- Comando cURL completo

## Ejemplos de Uso

### Ejemplo b√°sico

```python
from nebuia_handler import NebuiaHandler

# Inicializar el handler
handler = NebuiaHandler(
    client_id="tu_client_id",
    api_key="tu_api_key",
    api_secret="tu_api_secret"
)

# Definir documentos a procesar
documents = {
    "acta_constitutiva": "./documentos/acta.pdf",
    "actas_de_asamblea": "./documentos/asamblea.pdf"
}

# Procesar documentos
result = handler.process_documents(
    documents=documents,
    config_name="dictaminaci√≥n",
    wait_for_completion=True
)

# Extraer informaci√≥n relevante
extracted_info = handler.extract_document_entities(result)
print(extracted_info)
```

### Listar configuraciones disponibles

```python
handler.list_configurations()
```

### Procesar documentos y analizar verificaci√≥n

```python
# Definir documentos a procesar
documents = {
    "acta_constitutiva": "./documentos/acta.pdf",
    "actas_de_asamblea": "./documentos/asamblea.pdf"
}

# Procesar documentos sin procesamiento autom√°tico
result = handler.process_documents(
    documents=documents,
    config_name="dictaminaci√≥n",
    wait_for_completion=False,
    auto_process=False  # No procesar autom√°ticamente, solo verificar
)

# Analizar resultados de verificaci√≥n
for doc_type, verification in result.get("verification_results", {}).items():
    status = verification.get("status", False)
    print(f"Documento {doc_type}: {'Verificado' if status else 'Rechazado'}")
    
    if not status and "points" in verification:
        print("  Razones de rechazo:")
        for point in verification["points"]:
            print(f"  - {point}")
```

### Subir un documento y crear un job manualmente

```python
# Crear un registro
record_response = handler.client.create_record("dictaminaci√≥n")
record_id = record_response["id"]

# Subir un documento
handler.client.upload_document(
    record_id=record_id,
    file_path="./documentos/acta.pdf",
    document_type="acta_constitutiva"
)

# Obtener detalles del registro
record_details = handler.client.get_record_details(record_id)
document_id = None

# Encontrar el ID del documento
for document in record_details.get("documents", []):
    if document.get("document_type") == "acta_constitutiva":
        document_id = document.get("document_id")
        break

# Verificar el tipo de documento
if document_id:
    verification_result = handler.verify_document_type(record_id, document_id)
    
    # Si la verificaci√≥n es exitosa, crear un job
    if verification_result[0]:  # El primer elemento es un booleano que indica √©xito
        job_response = handler.client.create_processing_job(record_id)
        job_id = job_response.get("job_id")
        print(f"Job creado con ID: {job_id}")
```

## Ejemplos Detallados de M√©todos Principales

### 1. Inicializaci√≥n del Cliente

El primer paso es inicializar el cliente con las credenciales correctas.

#### M√©todo: `NebuiaHandler.__init__()`

```python
from nebuia_handler import NebuiaHandler
import logging

# Configurar logging (opcional pero recomendado)
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

# Inicializar el handler
handler = NebuiaHandler(
    client_id="c1b2a3d4-e5f6-7890-a1b2-c3d4e5f67890",
    api_key="pub_83f7c9b512345678abcdef0123456789",
    api_secret="sec_83f7c9b512345678abcdef0123456789",
    log_curl=True,  # Registrar comandos cURL para depuraci√≥n
    log_level=logging.INFO,  # Nivel de detalle del logging
    base_url="https://api.nebuia.com/v1"  # URL base de la API (opcional)
)
```

**¬øQu√© hace este c√≥digo?**
1. Importa la clase `NebuiaHandler` que encapsula toda la funcionalidad.
2. Configura el sistema de logging para obtener informaci√≥n √∫til durante el proceso.
3. Inicializa el cliente con las credenciales necesarias:
   - `client_id`: Identificador √∫nico del cliente en Nebuia.
   - `api_key`: Clave p√∫blica para las solicitudes a la API.
   - `api_secret`: Clave secreta para autenticaci√≥n.
4. Habilita el registro de comandos cURL para facilitar la depuraci√≥n.
5. Establece el nivel de detalle de los mensajes de log.
6. Opcionalmente, especifica la URL base de la API.

**Respuesta de la API:** No hay respuesta directa, ya que este m√©todo inicializa el cliente localmente.

### 2. Creaci√≥n de un Registro

Un registro (record) es un contenedor que agrupa documentos relacionados.

#### M√©todo: `NebuiaClient.create_record()`

```python
try:
    # Crear un nuevo registro usando una configuraci√≥n espec√≠fica
    record_response = handler.client.create_record(
        config_name="dictaminaci√≥n_fiscal"
    )
    
    # Extraer el ID del registro para su uso posterior
    record_id = record_response["id"]
    
    print(f"Registro creado con ID: {record_id}")
    print(f"Detalles del registro: {record_response}")
    
except Exception as e:
    print(f"Error al crear el registro: {str(e)}")
```

**¬øQu√© hace este c√≥digo?**
1. Llama al m√©todo `create_record()` del cliente Nebuia.
2. Especifica la configuraci√≥n que se utilizar√° para este registro mediante `config_name`.
3. Recibe la respuesta de la API y extrae el ID del registro para uso futuro.
4. Maneja posibles errores durante el proceso.

**Respuesta de la API:**
```json
{
  "id": "r1b2a3d4-e5f6-7890-a1b2-c3d4e5f67890",
  "client_id": "c1b2a3d4-e5f6-7890-a1b2-c3d4e5f67890",
  "configuration_ref": "dictaminaci√≥n_fiscal",
  "status": "waiting",
  "created_at": "2025-04-16T10:15:30Z",
  "documents": []
}
```

### 3. Subida de Documentos

Una vez creado el registro, se pueden subir documentos asociados a tipos espec√≠ficos.

#### M√©todo: `NebuiaClient.upload_document()`

```python
# Definir la ruta al archivo PDF
file_path = "./documentos/acta_constitutiva.pdf"
document_type = "acta_constitutiva"

try:
    # Subir el documento al registro creado anteriormente
    upload_response = handler.client.upload_document(
        record_id=record_id,
        file_path=file_path,
        document_type=document_type,
        timeout=300  # Tiempo m√°ximo de espera en segundos
    )
    
    # Extraer el ID del documento
    document_id = upload_response["document_id"]
    
    print(f"Documento subido con ID: {document_id}")
    print(f"Detalles de la carga: {upload_response}")
    
except Exception as e:
    print(f"Error al subir el documento: {str(e)}")
```

**¬øQu√© hace este c√≥digo?**
1. Define la ruta al archivo PDF que se va a subir y su tipo seg√∫n la configuraci√≥n.
2. Llama al m√©todo `upload_document()` con los par√°metros necesarios:
   - `record_id`: ID del registro al que pertenecer√° el documento.
   - `file_path`: Ruta completa al archivo PDF.
   - `document_type`: Tipo de documento seg√∫n la configuraci√≥n.
   - `timeout`: Tiempo m√°ximo de espera para la operaci√≥n.
3. Extrae el ID del documento para referencia futura.
4. Maneja posibles errores en el proceso de carga.

**Respuesta de la API:**
```json
{
  "document_id": "doc_12345678abcdef0123456789",
  "document_type": "acta_constitutiva",
  "status": "waiting",
  "created_at": "2025-04-16T10:30:45Z"
}
```

#### Subida de M√∫ltiples Documentos

```python
# Definir un diccionario de documentos a subir
documents = {
    "acta_constitutiva": "./documentos/acta_constitutiva.pdf",
    "actas_de_asamblea": "./documentos/actas_asamblea.pdf",
    "poder_notarial": "./documentos/poder_notarial.pdf"
}

document_ids = {}  # Para almacenar los IDs de los documentos

# Iterar a trav√©s de los documentos y subirlos
for doc_type, file_path in documents.items():
    try:
        # Verificar que el archivo existe y es accesible
        if not os.path.isfile(file_path):
            print(f"El archivo {file_path} no existe o no es accesible.")
            continue
            
        # Subir el documento
        response = handler.client.upload_document(
            record_id=record_id,
            file_path=file_path,
            document_type=doc_type
        )
        
        # Guardar el ID del documento
        document_ids[doc_type] = response["document_id"]
        
        print(f"Documento {doc_type} subido con ID: {document_ids[doc_type]}")
        
    except Exception as e:
        print(f"Error al subir el documento {doc_type}: {str(e)}")
```

**¬øQu√© hace este c√≥digo?**
1. Define un diccionario donde las claves son los tipos de documentos y los valores son las rutas a los archivos.
2. Crea un diccionario vac√≠o para almacenar los IDs de los documentos subidos.
3. Itera a trav√©s de cada documento:
   - Verifica que el archivo exista y sea accesible.
   - Sube el documento al registro.
   - Almacena el ID del documento para uso posterior.
4. Maneja los errores individualmente para cada documento.

### 4. Espera por Procesamiento de Embeddings

Despu√©s de subir los documentos, es necesario esperar a que el motor de embeddings los procese inicialmente.

#### M√©todo: `NebuiaHandler._wait_for_embedding()`

```python
# Esta funci√≥n es parte de process_documents(), pero se puede usar independientemente
def wait_for_embedding_example(handler, record_id, document_ids):
    print("Esperando a que los documentos sean procesados por el motor de embeddings...")
    
    # Callback para mostrar progreso
    def status_callback(progress, total, completed_docs):
        percentage = (progress / total) * 100 if total > 0 else 0
        print(f"Progreso: {percentage:.2f}% ({progress}/{total} documentos procesados)")
        for doc_id, status in completed_docs.items():
            print(f"  - Documento {doc_id}: {status}")
    
    try:
        # Esperar a que todos los documentos est√©n en estado "complete"
        embedding_success = handler._wait_for_embedding(
            record_id=record_id,
            document_ids=list(document_ids.values()),
            interval=5,  # Intervalo de consulta en segundos
            timeout=300,  # Tiempo m√°ximo de espera en segundos
            status_callback=status_callback
        )
        
        if embedding_success:
            print("Todos los documentos han sido procesados correctamente.")
            return True
        else:
            print("No se pudieron procesar todos los documentos en el tiempo establecido.")
            return False
            
    except Exception as e:
        print(f"Error durante la espera por embeddings: {str(e)}")
        return False

# Uso del ejemplo
wait_for_embedding_example(handler, record_id, document_ids)
```

**¬øQu√© hace este c√≥digo?**
1. Define una funci√≥n de ejemplo para esperar por el procesamiento de embeddings.
2. Crea una funci√≥n de callback para mostrar el progreso durante la espera.
3. Llama al m√©todo `_wait_for_embedding()` con los par√°metros necesarios:
   - `record_id`: ID del registro que contiene los documentos.
   - `document_ids`: Lista de IDs de documentos a monitorear.
   - `interval`: Tiempo entre consultas de estado en segundos.
   - `timeout`: Tiempo m√°ximo de espera en segundos.
   - `status_callback`: Funci√≥n para reportar el progreso.
4. Devuelve un booleano que indica si todos los documentos se procesaron exitosamente.

**Respuesta de la API (durante monitoreo):**
```json
{
  "id": "r1b2a3d4-e5f6-7890-a1b2-c3d4e5f67890",
  "status": "waiting",
  "documents": [
    {
      "document_id": "doc_12345678abcdef0123456789",
      "document_type": "acta_constitutiva",
      "status": "processing",
      "progress": 0.45
    },
    {
      "document_id": "doc_98765432abcdef0123456789",
      "document_type": "actas_de_asamblea",
      "status": "waiting",
      "progress": 0.0
    }
  ]
}
```

### 5. Verificaci√≥n de Tipos de Documentos

Una vez procesados los documentos, es necesario verificar que sean del tipo correcto.

#### M√©todo: `NebuiaClient.verify_document_type()`

```python
def verify_single_document(handler, record_id, document_id, expected_type):
    try:
        # Verificar el tipo de documento
        verification_result = handler.client.verify_document_type(
            record_id=record_id,
            document_id=document_id
        )
        
        # Analizar el resultado
        is_valid = verification_result.get("status", False)
        
        if is_valid:
            print(f"‚úÖ Documento verificado como: {expected_type}")
            return True
        else:
            print(f"‚ùå Documento inv√°lido. Verificaci√≥n fallida.")
            print(f"   Tipo encontrado: {verification_result.get('type_document_found', 'desconocido')}")
            
            if "points" in verification_result:
                print("   Razones:")
                for i, point in enumerate(verification_result["points"], 1):
                    print(f"   {i}. {point}")
                    
            return False
            
    except Exception as e:
        print(f"Error durante la verificaci√≥n: {str(e)}")
        return False

# Ejemplo de uso con un documento individual
doc_id = document_ids["acta_constitutiva"]
verify_single_document(handler, record_id, doc_id, "acta_constitutiva")
```

**¬øQu√© hace este c√≥digo?**
1. Define una funci√≥n para verificar un documento individual.
2. Llama al m√©todo `verify_document_type()` con los par√°metros necesarios:
   - `record_id`: ID del registro que contiene el documento.
   - `document_id`: ID del documento a verificar.
3. Analiza el resultado de la verificaci√≥n:
   - Comprueba si el documento es v√°lido (status=true).
   - Si no es v√°lido, muestra el tipo detectado y las razones del fallo.

**Respuesta de la API (verificaci√≥n exitosa):**
```json
{
  "status": true,
  "type_document_found": "acta_constitutiva",
  "points": [
    "El documento contiene todas las secciones requeridas para un acta constitutiva",
    "Se identificaron estatutos correctamente",
    "Firmas validadas correctamente"
  ]
}
```

**Respuesta de la API (verificaci√≥n fallida):**
```json
{
  "status": false,
  "type_document_found": "otro_tipo_documento",
  "points": [
    "El documento no contiene las secciones esperadas para un acta constitutiva",
    "No se encontr√≥ la secci√≥n de estatutos",
    "No se identificaron las firmas requeridas"
  ]
}
```

#### M√©todo: `NebuiaHandler._verify_all_documents()`

```python
def verify_all_documents_example(handler, record_id, document_ids):
    print("Verificando todos los documentos...")
    
    try:
        # Preparar el mapeo de document_id -> document_type
        document_types = {}
        for doc_type, doc_id in document_ids.items():
            document_types[doc_id] = doc_type
        
        # Verificar todos los documentos
        verification_results, all_passed = handler._verify_all_documents(
            record_id=record_id,
            document_ids=list(document_ids.values())
        )
        
        # Analizar resultados
        print(f"\nResumen de verificaci√≥n:")
        print(f"Todos los documentos verificados: {all_passed}")
        
        for doc_id, result in verification_results.items():
            doc_type = document_types.get(doc_id, "tipo desconocido")
            status = result.get("status", False)
            print(f"\nDocumento: {doc_type} (ID: {doc_id})")
            print(f"Estado: {'‚úÖ Verificado' if status else '‚ùå Rechazado'}")
            
            if not status:
                print(f"Tipo detectado: {result.get('type_document_found', 'desconocido')}")
                if "points" in result:
                    print("Razones:")
                    for i, point in enumerate(result["points"], 1):
                        print(f"  {i}. {point}")
        
        return all_passed, verification_results
            
    except Exception as e:
        print(f"Error durante la verificaci√≥n de documentos: {str(e)}")
        return False, {}

# Uso del ejemplo
verification_passed, results = verify_all_documents_example(handler, record_id, document_ids)
```

**¬øQu√© hace este c√≥digo?**
1. Define una funci√≥n para verificar todos los documentos en un registro.
2. Prepara un mapeo entre IDs de documentos y sus tipos para referencia.
3. Llama al m√©todo `_verify_all_documents()` con los par√°metros necesarios.
4. Analiza y muestra los resultados de verificaci√≥n para cada documento.
5. Devuelve un booleano que indica si todos los documentos pasaron la verificaci√≥n y los resultados detallados.

### 6. Creaci√≥n de un Trabajo de Procesamiento

Si la verificaci√≥n es exitosa, el siguiente paso es crear un trabajo de procesamiento para extraer informaci√≥n de los documentos.

#### M√©todo: `NebuiaClient.create_processing_job()`

```python
def create_processing_job_example(handler, record_id):
    print(f"Creando trabajo de procesamiento para el registro {record_id}...")
    
    try:
        # Crear el trabajo de procesamiento
        job_response = handler.client.create_processing_job(record_id)
        
        # Extraer informaci√≥n relevante
        job_id = job_response.get("job_id")
        status = job_response.get("status")
        
        print(f"Trabajo creado exitosamente.")
        print(f"ID del trabajo: {job_id}")
        print(f"Estado inicial: {status}")
        
        return job_id
            
    except Exception as e:
        print(f"Error al crear el trabajo de procesamiento: {str(e)}")
        return None

# Uso del ejemplo (solo si la verificaci√≥n fue exitosa)
if verification_passed:
    job_id = create_processing_job_example(handler, record_id)
else:
    print("No se puede procesar debido a errores en la verificaci√≥n de documentos.")
```

**¬øQu√© hace este c√≥digo?**
1. Define una funci√≥n para crear un trabajo de procesamiento.
2. Llama al m√©todo `create_processing_job()` con el ID del registro.
3. Extrae informaci√≥n relevante de la respuesta, como el ID del trabajo y su estado.
4. Solo ejecuta la creaci√≥n del trabajo si todos los documentos pasaron la verificaci√≥n.

**Respuesta de la API:**
```json
{
  "job_id": "job_12345678abcdef0123456789",
  "record_id": "r1b2a3d4-e5f6-7890-a1b2-c3d4e5f67890",
  "status": "created",
  "message": "Processing job created successfully"
}
```

### 7. Espera por Finalizaci√≥n del Procesamiento

Una vez creado el trabajo, es necesario esperar a que se complete el procesamiento de todos los documentos.

#### M√©todo: `NebuiaClient.wait_for_record_completion()`

```python
def wait_for_processing_completion(handler, record_id):
    print(f"Esperando a que se complete el procesamiento del registro {record_id}...")
    
    # Callback para mostrar progreso
    def status_callback(status, progress, elapsed_time):
        if progress is not None:
            percentage = progress * 100
            print(f"Progreso: {percentage:.2f}% | Estado: {status} | Tiempo transcurrido: {elapsed_time:.2f}s")
        else:
            print(f"Estado: {status} | Tiempo transcurrido: {elapsed_time:.2f}s")
    
    try:
        # Esperar a que el registro complete su procesamiento
        completed_record = handler.client.wait_for_record_completion(
            record_id=record_id,
            timeout=1800,  # 30 minutos
            interval=10,   # Consultar cada 10 segundos
            status_callback=status_callback
        )
        
        print("\nProcesamiento completado exitosamente.")
        print(f"Estado final: {completed_record.get('status')}")
        
        return completed_record
            
    except Exception as e:
        print(f"Error durante la espera por procesamiento: {str(e)}")
        return None

# Uso del ejemplo
processed_record = wait_for_processing_completion(handler, record_id)
```

**¬øQu√© hace este c√≥digo?**
1. Define una funci√≥n para esperar la finalizaci√≥n del procesamiento.
2. Crea una funci√≥n de callback para mostrar el progreso durante la espera.
3. Llama al m√©todo `wait_for_record_completion()` con los par√°metros necesarios:
   - `record_id`: ID del registro a monitorear.
   - `timeout`: Tiempo m√°ximo de espera en segundos.
   - `interval`: Tiempo entre consultas de estado en segundos.
   - `status_callback`: Funci√≥n para reportar el progreso.
4. Devuelve el registro completo una vez finalizado el procesamiento.

**Respuesta de la API (durante monitoreo):**
```json
{
  "id": "r1b2a3d4-e5f6-7890-a1b2-c3d4e5f67890",
  "status": "processing",
  "progress": 0.65,
  "documents": [
    {
      "document_id": "doc_12345678abcdef0123456789",
      "document_type": "acta_constitutiva",
      "status": "completed",
      "progress": 1.0
    },
    {
      "document_id": "doc_98765432abcdef0123456789",
      "document_type": "actas_de_asamblea",
      "status": "processing",
      "progress": 0.3
    }
  ]
}
```

**Respuesta de la API (procesamiento finalizado):**
```json
{
  "id": "r1b2a3d4-e5f6-7890-a1b2-c3d4e5f67890",
  "status": "completed",
  "progress": 1.0,
  "documents": [
    {
      "document_id": "doc_12345678abcdef0123456789",
      "document_type": "acta_constitutiva",
      "status": "completed",
      "progress": 1.0,
      "entities": [
        {
          "nombre_empresa": "Corporaci√≥n Ejemplo S.A. de C.V.",
          "fecha_constitucion": "2020-01-15",
          "capital_social": "1,000,000.00"
        }
      ]
    },
    {
      "document_id": "doc_98765432abcdef0123456789",
      "document_type": "actas_de_asamblea",
      "status": "completed",
      "progress": 1.0,
      "entities": [
        {
          "fecha_asamblea": "2023-08-12",
          "tipo_asamblea": "Ordinaria",
          "acuerdos": ["Aprobaci√≥n de estados financieros", "Nombramiento de nuevo consejero"]
        }
      ]
    }
  ]
}
```

### 8. Extracci√≥n de Entidades de Documentos

Una vez completado el procesamiento, es posible extraer y estructurar la informaci√≥n relevante de los documentos.

#### M√©todo: `NebuiaHandler.extract_document_entities()`

```python
def extract_entities_example(handler, processed_record):
    if not processed_record or processed_record.get('status') != 'completed':
        print("El registro no est√° completado, no se pueden extraer entidades.")
        return {}
    
    print("Extrayendo entidades de los documentos procesados...")
    
    try:
        # Extraer las entidades de todos los documentos
        extracted_info = handler.extract_document_entities(processed_record)
        
        # Mostrar informaci√≥n extra√≠da por tipo de documento
        for doc_type, entities in extracted_info.items():
            print(f"\nüìÑ Documento: {doc_type}")
            
            if isinstance(entities, list):
                # Si hay m√∫ltiples entidades para este tipo de documento
                for i, entity in enumerate(entities, 1):
                    print(f"  Entidad {i}:")
                    for key, value in entity.items():
                        print(f"    - {key}: {value}")
            else:
                # Si hay una sola entidad para este tipo de documento
                for key, value in entities.items():
                    print(f"  - {key}: {value}")
        
        return extracted_info
            
    except Exception as e:
        print(f"Error durante la extracci√≥n de entidades: {str(e)}")
        return {}

# Uso del ejemplo
if processed_record:
    extracted_data = extract_entities_example(handler, processed_record)
```

**¬øQu√© hace este c√≥digo?**
1. Define una funci√≥n para extraer entidades de los documentos procesados.
2. Verifica que el registro est√© en estado "completed".
3. Llama al m√©todo `extract_document_entities()` con el registro procesado.
4. Muestra la informaci√≥n extra√≠da, organizada por tipo de documento.
5. Maneja diferentes estructuras de datos seg√∫n el documento tenga una o m√∫ltiples entidades.

**Estructura de los datos extra√≠dos:**
```python
{
    "acta_constitutiva": {
        "nombre_empresa": "Corporaci√≥n Ejemplo S.A. de C.V.",
        "fecha_constitucion": "2020-01-15",
        "capital_social": "1,000,000.00",
        "objeto_social": "Desarrollo de software y servicios de tecnolog√≠a"
    },
    "actas_de_asamblea": [
        {
            "fecha_asamblea": "2023-08-12",
            "tipo_asamblea": "Ordinaria",
            "acuerdos": ["Aprobaci√≥n de estados financieros", "Nombramiento de nuevo consejero"]
        }
    ]
}
```

### 9. Flujo Completo con process_documents()

El m√©todo `process_documents()` de `NebuiaHandler` encapsula todo el flujo anterior en una sola llamada.

#### M√©todo: `NebuiaHandler.process_documents()`

```python
def process_documents_complete_example():
    # Inicializar el handler
    handler = NebuiaHandler(
        client_id="c1b2a3d4-e5f6-7890-a1b2-c3d4e5f67890",
        api_key="pub_83f7c9b512345678abcdef0123456789",
        api_secret="sec_83f7c9b512345678abcdef0123456789",
        log_curl=True
    )
    
    # Definir documentos a procesar
    documents = {
        "acta_constitutiva": "./documentos/acta_constitutiva.pdf",
        "actas_de_asamblea": "./documentos/actas_asamblea.pdf",
        "poder_notarial": "./documentos/poder_notarial.pdf"
    }
    
    try:
        # Callback para mostrar progreso del procesamiento
        def status_callback(status, progress, elapsed_time):
            if progress is not None:
                percentage = progress * 100
                print(f"Progreso: {percentage:.2f}% | Estado: {status} | Tiempo transcurrido: {elapsed_time:.2f}s")
            else:
                print(f"Estado: {status} | Tiempo transcurrido: {elapsed_time:.2f}s")
        
        # Procesar todos los documentos en un solo paso
        result = handler.process_documents(
            documents=documents,
            config_name="dictaminaci√≥n_fiscal",
            wait_for_completion=True,
            auto_process=True,  # Procesar incluso si la verificaci√≥n falla
            timeout=1800,       # 30 minutos m√°ximo
            status_callback=status_callback
        )
        
        print("\n‚úÖ Procesamiento completado.")
        
        # Verificar si hay resultados de verificaci√≥n
        if "verification_results" in result:
            print("\nüìã Resultados de verificaci√≥n:")
            for doc_type, verification in result["verification_results"].items():
                status = verification.get("status", False)
                print(f"  - {doc_type}: {'‚úÖ Verificado' if status else '‚ùå Rechazado'}")
        
        # Extraer informaci√≥n procesada
        extracted_info = handler.extract_document_entities(result)
        
        # Mostrar informaci√≥n extra√≠da
        print("\nüìä Informaci√≥n extra√≠da:")
        for doc_type, entities in extracted_info.items():
            print(f"\n  üìÑ {doc_type}:")
            
            if isinstance(entities, list):
                for i, entity in enumerate(entities, 1):
                    print(f"    Entidad {i}:")
                    for k, v in entity.items():
                        print(f"      - {k}: {v}")
            else:
                for k, v in entities.items():
                    print(f"    - {k}: {v}")
        
        return result, extracted_info
            
    except Exception as e:
        print(f"‚ùå Error durante el procesamiento: {str(e)}")
        return None, {}

# Ejecutar el ejemplo completo
result, extracted_data = process_documents_complete_example()
```

**¬øQu√© hace este c√≥digo?**
1. Define una funci√≥n que implementa el flujo completo de procesamiento.
2. Inicializa el handler con las credenciales necesarias.
3. Define un diccionario de documentos a procesar.
4. Crea una funci√≥n de callback para mostrar el progreso.
5. Llama al m√©todo `process_documents()` con todos los par√°metros necesarios:
   - `documents`: Diccionario de documentos a procesar.
   - `config_name`: Nombre de la configuraci√≥n a utilizar.
   - `wait_for_completion`: Si debe esperar a que se complete el procesamiento.
   - `auto_process`: Si debe procesar incluso si la verificaci√≥n falla.
   - `timeout`: Tiempo m√°ximo de espera en segundos.
   - `status_callback`: Funci√≥n para reportar el progreso.
6. Muestra los resultados de verificaci√≥n.
7. Extrae y muestra la informaci√≥n procesada.

**Estructura de resultado completo:**
```python
{
    "id": "r1b2a3d4-e5f6-7890-a1b2-c3d4e5f67890",
    "status": "completed",
    "verification_results": {
        "acta_constitutiva": {
            "status": true,
            "type_document_found": "acta_constitutiva",
            "points": [...]
        },
        "actas_de_asamblea": {
            "status": true,
            "type_document_found": "actas_de_asamblea",
            "points": [...]
        },
        "poder_notarial": {
            "status": false,
            "type_document_found": "otro_tipo_documento",
            "points": [...]
        }
    },
    "documents": [
        {
            "document_type": "acta_constitutiva",
            "document_id": "doc_12345678abcdef0123456789",
            "status": "completed",
            "entities": [...]
        },
        ...
    ],
    "job_id": "job_12345678abcdef0123456789",
    "created_at": "2025-04-16T10:15:30Z",
    "completed_at": "2025-04-16T10:45:20Z"
}
```

### 10. Manejo de Errores

Es importante implementar un manejo robusto de errores al trabajar con la API de Nebuia.

#### Ejemplo de Manejo de Errores Espec√≠ficos

```python
from nebuia_client import NebuiaAPIError, NebuiaTimeoutError, NebuiaValidationError

def robust_document_processing(handler, documents, config_name):
    try:
        result = handler.process_documents(
            documents=documents,
            config_name=config_name,
            wait_for_completion=True
        )
        return True, result
        
    except NebuiaValidationError as e:
        print(f"‚ùå Error de validaci√≥n: {str(e)}")
        print("   ‚Üí Este error ocurre cuando hay problemas con los documentos o su formato.")
        print("   ‚Üí Verifica que los documentos sean PDFs v√°lidos y accesibles.")
        return False, {"error": "validation", "message": str(e)}
        
    except NebuiaTimeoutError as e:
        print(f"‚è±Ô∏è Error de tiempo de espera: {str(e)}")
        print("   ‚Üí El procesamiento ha tomado demasiado tiempo.")
        print("   ‚Üí Puedes intentar nuevamente o aumentar el timeout.")
        return False, {"error": "timeout", "message": str(e)}
        
    except NebuiaAPIError as e:
        print(f"üåê Error de API: {str(e)}")
        print(f"   ‚Üí C√≥digo HTTP: {e.status_code}")
        print(f"   ‚Üí Respuesta: {e.response}")
        
        if e.status_code == 401:
            print("   ‚Üí Verifica tus credenciales de API.")
        elif e.status_code == 404:
            print("   ‚Üí Recurso no encontrado. Verifica los IDs utilizados.")
        elif e.status_code == 429:
            print("   ‚Üí L√≠mite de tasa excedido. Espera un momento e intenta nuevamente.")
        
        return False, {"error": "api", "code": e.status_code, "message": str(e)}
        
    except Exception as e:
        print(f"‚ö†Ô∏è Error inesperado: {str(e)}")
        print("   ‚Üí Este es un error no controlado espec√≠ficamente.")
        return False, {"error": "unknown", "message": str(e)}

# Uso de la funci√≥n robusta
success, result = robust_document_processing(
    handler,
    documents={"acta_constitutiva": "./documentos/acta.pdf"},
    config_name="dictaminaci√≥n_fiscal"
)

if success:
    print("‚úÖ Procesamiento exitoso!")
    extracted_info = handler.extract_document_entities(result)
    # Hacer algo con la informaci√≥n extra√≠da
else:
    print(f"‚ùå Procesamiento fallido: {result['error']} - {result['message']}")
    # Implementar l√≥gica de recuperaci√≥n o reintento
```

**¬øQu√© hace este c√≥digo?**
1. Define una funci√≥n que implementa manejo robusto de errores espec√≠ficos.
2. Captura diferentes tipos de excepciones que pueden ocurrir durante el procesamiento:
   - `NebuiaValidationError`: Problemas con los documentos o su formato.
   - `NebuiaTimeoutError`: El procesamiento ha tomado demasiado tiempo.
   - `NebuiaAPIError`: Errores espec√≠ficos de la API, con c√≥digos HTTP.
   - `Exception`: Cualquier otro error no controlado espec√≠ficamente.
3. Proporciona mensajes informativos y sugerencias para cada tipo de error.
4. Devuelve una estructura uniforme para facilitar el manejo de errores.
5. Demuestra c√≥mo usar la funci√≥n y manejar sus resultados de manera apropiada.

## Ejemplos de Respuestas de la API

A continuaci√≥n se detallan los formatos de respuesta para cada endpoint principal, tanto para casos de √©xito como de error.

### 1. Creaci√≥n de Cliente (`POST /clients`)

Este endpoint permite crear un nuevo cliente y genera sus credenciales de API.

#### Solicitud

```json
{
  "email": "empresa@ejemplo.com",
  "password": "contrase√±a_segura",
  "name": "Empresa Ejemplo",
  "quota": 1000
}
```

#### Respuesta Exitosa (201 Created)

```json
{
  "id": "c1b2a3d4-e5f6-7890-a1b2-c3d4e5f67890",
  "api_keys": {
    "public_key": "pub_83f7c9b512345678abcdef0123456789",
    "secret_key": "sec_83f7c9b512345678abcdef0123456789"
  }
}
```

**Descripci√≥n de campos:**
- `id`: Identificador √∫nico del cliente (UUID) en la plataforma Nebuia.
- `api_keys`: Objeto que contiene las claves de API para autenticaci√≥n:
  - `public_key`: Clave p√∫blica que debe usarse en solicitudes a la API.
  - `secret_key`: Clave secreta que debe mantenerse segura y usarse para autenticaci√≥n.

#### Respuesta de Error (400 Bad Request - Email Duplicado)

```json
{
  "error": true,
  "message": "A user already exists with email empresa@ejemplo.com"
}
```

### 2. Obtener Cliente (`GET /clients/:client_id`)

Este endpoint recupera la informaci√≥n de un cliente espec√≠fico.

#### Respuesta Exitosa (200 OK)

```json
{
  "id": "c1b2a3d4-e5f6-7890-a1b2-c3d4e5f67890",
  "name": "Empresa Ejemplo",
  "api_key": "pub_83f7c9b512345678abcdef0123456789",
  "secret_key": "sec_83f7c9b512345678abcdef0123456789",
  "quota": 1000,
  "used_quota": 42,
  "created_at": "2025-01-15T10:30:45Z",
  "configurations": {
    "dictaminaci√≥n": {
      "documents": {
        "acta_constitutiva": {
          "required": true,
          "entities": [
            {
              "structure": {
                "nombre_empresa": "",
                "fecha_constitucion": "",
                "capital_social": ""
              },
              "query": "Extrae la informaci√≥n b√°sica de la empresa",
              "name_to_show": "Informaci√≥n B√°sica"
            }
          ]
        },
        "actas_de_asamblea": {
          "required": false,
          "entities": [
            {
              "structure": {
                "fecha_asamblea": "",
                "tipo_asamblea": "",
                "acuerdos": []
              },
              "query": "Extrae la informaci√≥n de la asamblea",
              "name_to_show": "Informaci√≥n de Asamblea"
            }
          ]
        }
      }
    }
  },
  "flows": {
    "dictaminaci√≥n_fiscal": {
      "name": "Dictaminaci√≥n Fiscal",
      "description": "Flujo para dictaminar documentos fiscales",
      "configuration_refs": [
        {
          "name": "dictaminaci√≥n",
          "type": "primary"
        }
      ],
      "created_at": "2025-02-10T14:22:10Z"
    }
  }
}
```

**Descripci√≥n de campos:**
- `id`: Identificador √∫nico del cliente.
- `name`: Nombre del cliente.
- `api_key`: Clave p√∫blica para autenticaci√≥n en la API.
- `secret_key`: Clave secreta para autenticaci√≥n.
- `quota`: Cuota total asignada al cliente.
- `used_quota`: Cuota utilizada hasta el momento.
- `created_at`: Fecha de creaci√≥n del cliente.
- `configurations`: Mapa de configuraciones disponibles para el cliente.
- `flows`: Mapa de flujos de trabajo definidos para el cliente.

#### Respuesta de Error (404 Not Found)

```json
{
  "error": true,
  "message": "Client not found"
}
```

### 3. Crear Configuraci√≥n (`POST /clients/:client_id/configurations/:config_name`)

Este endpoint crea o actualiza una configuraci√≥n para un cliente espec√≠fico.

#### Solicitud

```json
{
  "documents": {
    "acta_constitutiva": {
      "required": true,
      "entities": [
        {
          "structure": {
            "nombre_empresa": "",
            "fecha_constitucion": "",
            "capital_social": ""
          },
          "query": "Extrae la informaci√≥n b√°sica de la empresa",
          "name_to_show": "Informaci√≥n B√°sica"
        }
      ]
    },
    "actas_de_asamblea": {
      "required": false,
      "entities": [
        {
          "structure": {
            "fecha_asamblea": "",
            "tipo_asamblea": "",
            "acuerdos": []
          },
          "query": "Extrae la informaci√≥n de la asamblea",
          "name_to_show": "Informaci√≥n de Asamblea"
        }
      ]
    }
  }
}
```

#### Respuesta Exitosa (200 OK)

```json
{
  "message": "Configuration dictaminaci√≥n added successfully"
}
```

#### Respuesta de Error (404 Not Found)

```json
{
  "error": true,
  "message": "Client not found"
}
```

### 4. Agregar Documento a un Registro (`POST /clients/:client_id/records/:record_id/documents`)

Este endpoint a√±ade un documento a un registro existente.

#### Solicitud

Formulario multipart con los siguientes campos:
- `file`: Archivo PDF del documento
- `document_type`: Tipo de documento (e.g., "acta_constitutiva")
- `process_document`: Bool (opcional, default: false)

#### Respuesta Exitosa (Sin Procesamiento, 200 OK)

```json
{
  "message": "Document added to record successfully",
  "document": {
    "document_type": "acta_constitutiva",
    "document_id": "doc_12345678abcdef0123456789",
    "structure": {},
    "created_at": "2025-04-16T10:30:45Z"
  }
}
```

**Descripci√≥n de campos:**
- `message`: Mensaje de confirmaci√≥n.
- `document`: Objeto que representa el documento a√±adido:
  - `document_type`: Tipo de documento seg√∫n la configuraci√≥n.
  - `document_id`: Identificador √∫nico del documento.
  - `structure`: Estructura inicial vac√≠a (se llenar√° durante el procesamiento).
  - `created_at`: Fecha y hora de creaci√≥n del documento.

#### Respuesta Exitosa (Con Procesamiento Autom√°tico, 200 OK)

```json
{
  "message": "Document successfully processed",
  "job_id": "job_12345678abcdef0123456789",
  "document": {
    "document_type": "acta_constitutiva",
    "document_id": "doc_12345678abcdef0123456789",
    "structure": {},
    "created_at": "2025-04-16T10:30:45Z"
  }
}
```

**Campos adicionales:**
- `job_id`: Identificador del trabajo de procesamiento creado.

#### Respuesta de Error (400 Bad Request - Tipo de Documento No Permitido)

```json
{
  "error": true,
  "message": "Document type acta_fiscal not allowed"
}
```

### 5. Crear un Registro (`POST /clients/:client_id/records/create`)

Este endpoint crea un nuevo registro para procesar documentos.

#### Solicitud

```json
{
  "configuration_ref": "dictaminaci√≥n",
  "with_email": true,
  "email": "usuario@ejemplo.com",
  "flow_name": "dictaminaci√≥n_fiscal"
}
```

#### Respuesta Exitosa (201 Created)

```json
{
  "id": "r1b2a3d4-e5f6-7890-a1b2-c3d4e5f67890",
  "message": "Record created successfully"
}
```

**Descripci√≥n de campos:**
- `id`: Identificador √∫nico del registro creado.
- `message`: Mensaje de confirmaci√≥n.

#### Respuesta de Error (400 Bad Request)

```json
{
  "error": true,
  "message": "Configuration dictaminacion_fiscal not found"
}
```

### 6. Crear un Flujo (`POST /clients/:client_id/flows/:flow_name`)

Este endpoint crea un nuevo flujo de trabajo.

#### Solicitud

```json
{
  "name": "Dictaminaci√≥n Fiscal",
  "description": "Flujo para dictaminar documentos fiscales",
  "configuration_refs": [
    {
      "name": "dictaminaci√≥n",
      "type": "primary"
    },
    {
      "name": "fiscal",
      "type": "secondary"
    }
  ]
}
```

#### Respuesta Exitosa (200 OK)

```json
{
  "message": "Flow dictaminaci√≥n_fiscal created successfully"
}
```

#### Respuesta de Error (400 Bad Request)

```json
{
  "error": true,
  "message": "Configuration dictaminaci√≥n_inexistente not found"
}
```

### 7. Crear un Trabajo de Procesamiento (`POST /clients/:client_id/records/:record_id/process`)

Este endpoint crea un trabajo para procesar todos los documentos en un registro.

#### Respuesta Exitosa (Trabajo Creado, 200 OK)

```json
{
  "job_id": "job_12345678abcdef0123456789",
  "message": "Processing job created successfully",
  "status": "created"
}
```

**Descripci√≥n de campos:**
- `job_id`: Identificador √∫nico del trabajo de procesamiento.
- `message`: Mensaje de confirmaci√≥n.
- `status`: Estado del trabajo ("created").

#### Respuesta (Registro Ya en Procesamiento, 200 OK)

```json
{
  "job_id": "job_12345678abcdef0123456789",
  "message": "Record is already being processed",
  "status": "already_processing"
}
```

#### Respuesta (Documentos Requeridos Faltantes, 200 OK)

```json
{
  "message": "Missing required documents: [\"acta_constitutiva\",\"actas_de_asamblea\"]",
  "status": "missing_documents",
  "missing_documents": ["acta_constitutiva", "actas_de_asamblea"]
}
```

### 8. Verificar Tipo de Documento (`GET /clients/:client_id/records/:record_id/type/:document_id`)

Este endpoint verifica si un documento es del tipo declarado.

#### Respuesta Exitosa (Documento Verificado, 200 OK)

```json
{
  "status": true,
  "type_document_found": "acta_constitutiva",
  "points": [
    "El documento contiene todas las secciones requeridas",
    "Se identificaron estatutos correctamente",
    "Firmas validadas correctamente"
  ]
}
```

**Descripci√≥n de campos:**
- `status`: Boolean que indica si la verificaci√≥n fue exitosa.
- `type_document_found`: Tipo de documento identificado por el sistema.
- `points`: Lista de puntos o criterios que confirman el tipo de documento.

#### Respuesta Fallida (Documento de Tipo Incorrecto, 200 OK)

```json
{
  "status": false,
  "type_document_found": "otro_tipo_documento",
  "points": [
    "El documento no contiene las secciones esperadas para un acta constitutiva",
    "No se encontr√≥ la secci√≥n de estatutos",
    "No se identificaron las firmas requeridas"
  ]
}
```

### 9. Obtener Detalles de un Registro (`GET /clients/:client_id/records/:record_id`)

Este endpoint recupera los detalles completos de un registro espec√≠fico.

#### Respuesta Exitosa (200 OK)

```json
{
  "id": "r1b2a3d4-e5f6-7890-a1b2-c3d4e5f67890",
  "configuration_ref": "dictaminaci√≥n",
  "documents": [
    {
      "document_type": "acta_constitutiva",
      "document_id": "doc_12345678abcdef0123456789",
      "created_at": "2025-04-16T10:30:45Z",
      "document_predict": {
        "status": true,
        "type_document_found": "acta_constitutiva",
        "points": [
          "El documento contiene todas las secciones requeridas",
          "Se identificaron estatutos correctamente",
          "Firmas validadas correctamente"
        ]
      },
      "entities": [
        {
          "structure": {
            "nombre_empresa": "Corporaci√≥n Ejemplo S.A. de C.V.",
            "fecha_constitucion": "2020-01-15",
            "capital_social": "1,000,000.00"
          },
          "query": "Extrae la informaci√≥n b√°sica de la empresa",
          "name_to_show": "Informaci√≥n B√°sica"
        }
      ]
    },
    {
      "document_type": "actas_de_asamblea",
      "document_id": "doc_98765432abcdef0123456789",
      "created_at": "2025-04-16T11:15:22Z",
      "document_predict": {
        "status": true,
        "type_document_found": "actas_de_asamblea",
        "points": [
          "El documento contiene todas las secciones esperadas de un acta de asamblea",
          "Se identificaron los acuerdos correctamente",
          "Se validaron las firmas de los asistentes"
        ]
      },
      "entities": [
        {
          "structure": {
            "fecha_asamblea": "2023-08-12",
            "tipo_asamblea": "Ordinaria",
            "acuerdos": [
              "Aprobaci√≥n de estados financieros",
              "Nombramiento de nuevo consejero"
            ]
          },
          "query": "Extrae la informaci√≥n de la asamblea",
          "name_to_show": "Informaci√≥n de Asamblea"
        }
      ]
    }
  ],
  "status": "completed",
  "created_at": "2025-04-16T10:15:30Z",
  "response_client": {},
  "allowed_documents": {
    "acta_constitutiva": {
      "required": true,
      "entities": [
        {
          "structure": {
            "nombre_empresa": "",
            "fecha_constitucion": "",
            "capital_social": ""
          },
          "query": "Extrae la informaci√≥n b√°sica de la empresa",
          "name_to_show": "Informaci√≥n B√°sica"
        }
      ]
    },
    "actas_de_asamblea": {
      "required": false,
      "entities": [
        {
          "structure": {
            "fecha_asamblea": "",
            "tipo_asamblea": "",
            "acuerdos": []
          },
          "query": "Extrae la informaci√≥n de la asamblea",
          "name_to_show": "Informaci√≥n de Asamblea"
        }
      ]
    }
  },
  "is_processing": false,
  "keys_not_found": [],
  "current_document_id": null
}
```

**Descripci√≥n de campos:**
- `id`: Identificador √∫nico del registro.
- `configuration_ref`: Referencia a la configuraci√≥n utilizada.
- `documents`: Array de documentos procesados, cada uno con:
  - `document_type`: Tipo de documento.
  - `document_id`: Identificador √∫nico del documento.
  - `created_at`: Fecha de creaci√≥n.
  - `document_predict`: Resultado de la verificaci√≥n del tipo de documento.
  - `entities`: Informaci√≥n extra√≠da del documento.
- `status`: Estado actual del registro.
- `created_at`: Fecha de creaci√≥n del registro.
- `allowed_documents`: Documentos permitidos seg√∫n la configuraci√≥n.
- `is_processing`: Indica si el registro est√° siendo procesado actualmente.

### 10. Listar Registros (`GET /clients/:client_id/records`)

Este endpoint lista todos los registros asociados a un cliente, con paginaci√≥n.

#### Solicitud

```
?page=1&page_size=10
```

#### Respuesta Exitosa (200 OK)

```json
{
  "data": [
    {
      "id": "r1b2a3d4-e5f6-7890-a1b2-c3d4e5f67890",
      "configuration_ref": "dictaminaci√≥n",
      "created_at": "2025-04-16T10:15:30Z",
      "status": "completed",
      "document_count": 2
    },
    {
      "id": "s2c3b4d5-f6g7-8901-b2c3-d4e5f6g78901",
      "configuration_ref": "dictaminaci√≥n",
      "created_at": "2025-04-15T14:22:10Z",
      "status": "processing",
      "document_count": 1
    }
  ],
  "pagination": {
    "current_page": 1,
    "page_size": 10,
    "total_items": 2,
    "total_pages": 1
  }
}
```

### 11. Procesar Documento para Extracci√≥n de Informaci√≥n (`POST /clients/:client_id/records/:record_id/single/inference/record`)

Este endpoint procesa un documento espec√≠fico para extraer informaci√≥n estructurada.

#### Solicitud

```json
{
  "doc_id": "doc_12345678abcdef0123456789",
  "query": "Extrae la informaci√≥n b√°sica de la empresa",
  "data": {
    "additional_context": "Documento de constituci√≥n de sociedad mercantil"
  }
}
```

#### Respuesta Exitosa (200 OK)

```json
{
  "structure": {
    "nombre_empresa": "Corporaci√≥n Ejemplo S.A. de C.V.",
    "fecha_constitucion": "2020-01-15",
    "capital_social": "1,000,000.00",
    "objeto_social": "Desarrollo de software y servicios de tecnolog√≠a"
  },
  "pages": [
    {
      "page_number": 1,
      "text": "ACTA CONSTITUTIVA...",
      "confidence": 0.95
    },
    {
      "page_number": 2,
      "text": "CL√ÅUSULAS...",
      "confidence": 0.97
    }
  ]
}
```

### 12. Login de Usuario (`POST /clients/auth/login`)

Este endpoint permite autenticar a un usuario y obtener una clave temporal.

#### Solicitud

```json
{
  "email": "usuario@ejemplo.com",
  "password": "contrase√±a_segura"
}
```

#### Respuesta Exitosa (200 OK)

```json
{
  "temporal_key": "temp_83f7c9b512345678abcdef0123456789"
}
```

#### Respuesta de Error (404 Not Found)

```json
{
  "error": true,
  "message": "User not found"
}
```

### 13. Obtener Estado de Trabajos del Cliente (`GET /clients/:client_id/records/jobs/status/metrics`)

Este endpoint recupera m√©tricas sobre los trabajos de procesamiento de un cliente.

#### Solicitud (Resumen)

```
?detailed=false
```

#### Respuesta Exitosa (Resumen, 200 OK)

```json
{
  "is_processing": true,
  "job_id": "job_12345678abcdef0123456789",
  "record_id": "r1b2a3d4-e5f6-7890-a1b2-c3d4e5f67890",
  "document_id": "doc_12345678abcdef0123456789",
  "started_at": "2025-04-16T10:30:45Z"
}
```

#### Solicitud (Detallada)

```
?detailed=true&status_filter=completed&page=1&page_size=10
```

#### Respuesta Exitosa (Detallada, 200 OK)

```json
{
  "jobs": {
    "processing": [
      {
        "job_id": "job_12345678abcdef0123456789",
        "record_id": "r1b2a3d4-e5f6-7890-a1b2-c3d4e5f67890",
        "document_id": "doc_12345678abcdef0123456789",
        "current_document_id": "doc_12345678abcdef0123456789",
        "status": "processing",
        "started_at": "2025-04-16T10:30:45Z",
        "created_at": "2025-04-16T10:30:40Z"
      }
    ],
    "pending": [],
    "completed": [],
    "failed": [],
    "cancelled": []
  },
  "metrics": {
    "total_jobs": 1,
    "processing_count": 1,
    "pending_count": 0,
    "completed_count": 0,
    "failed_count": 0,
    "cancelled_count": 0,
    "average_processing_time": "0:00:00",
    "success_rate": 0
  },
  "pagination": {
    "current_page": 1,
    "page_size": 10,
    "total_items": 1,
    "total_pages": 1
  }
}
```

### 14. Cancelar un Trabajo (`DELETE /clients/:client_id/records/jobs/cancel/:job_id`)

Este endpoint cancela un trabajo de procesamiento en curso.

#### Respuesta Exitosa (200 OK)

```json
{
  "status": "success",
  "message": "Job canceled successfully"
}
```

#### Respuesta de Error (400 Bad Request)

```json
{
  "error": true,
  "message": "You can't cancel a job with status completed"
}
```

### 15. Eliminar un Trabajo (`DELETE /clients/:client_id/records/jobs/delete/:job_id`)

Este endpoint elimina un trabajo de procesamiento que no est√° en curso.

#### Respuesta Exitosa (200 OK)

```json
{
  "status": "success",
  "message": "Job deleted successfully"
}
```

#### Respuesta de Error (400 Bad Request)

```json
{
  "error": true,
  "message": "Cannot delete a job that is currently processing. Cancel it first."
}
```

### 16. Reprocesar un Trabajo (`POST /clients/:client_id/records/:record_id/reprocess/job/:job_id`)

Este endpoint crea un nuevo trabajo para reprocesar un registro basado en un trabajo anterior.

#### Respuesta Exitosa (200 OK)

```json
{
  "job_id": "job_45678901abcdef0123456789"
}
```

### 17. Obtener Informaci√≥n de Cuota (`GET /clients/:client_id/quota`)

Este endpoint obtiene la informaci√≥n actual de cuota de un cliente.

#### Respuesta Exitosa (200 OK)

```json
{
  "quota": 1000,
  "used_quota": 42,
  "remaining_quota": 958
}
```

## Soluci√≥n de Problemas

### Problema: Error de autenticaci√≥n

**Mensaje de error:**
```
API Error (401): Request failed: Unauthorized
```

**Soluci√≥n:**
- Verifica que las credenciales (client_id, api_key, api_secret) sean correctas
- Comprueba que la cuenta tenga acceso al servicio de Nebuia
- Aseg√∫rate de que las credenciales no est√©n caducadas

### Problema: Timeout durante el procesamiento

**Mensaje de error:**
```
Timeout exceeded for record xxx after 300 seconds
```

**Soluci√≥n:**
- Aumenta el par√°metro `timeout` al llamar a `process_documents`
- Verifica el estado del documento manualmente usando `get_record_details`
- Considera procesar documentos m√°s peque√±os o dividir documentos grandes

### Problema: Fallo en la verificaci√≥n del tipo de documento

**Comportamiento:**
La funci√≥n `process_documents` devuelve un resultado, pero no se crea un trabajo de procesamiento.

**Soluci√≥n:**
- Revisa los resultados de verificaci√≥n para entender por qu√© fall√≥
- Aseg√∫rate de que los documentos son del tipo correcto
- Usa el par√°metro `auto_process=True` para forzar el procesamiento sin importar la verificaci√≥n

### Problema: Documento en estado "waiting" permanentemente

**Comportamiento:**
El documento queda en estado "waiting" y nunca pasa a "complete".

**Soluci√≥n:**
- Verifica que el documento sea legible y no est√© da√±ado
- Comprueba que el documento no est√© protegido con contrase√±a
- Intenta optimizar el PDF (reducir tama√±o, mejorar calidad de escaneo)
- Contacta al soporte de Nebuia si el problema persiste

### Problema: Errores en el formato de los resultados

**Comportamiento:**
La estructura de los datos extra√≠dos no es la esperada.

**Soluci√≥n:**
- Utiliza la funci√≥n `extract_document_entities` para limpiar y estructurar los resultados
- Verifica la configuraci√≥n en Nebuia para asegurarte de que est√° configurada correctamente
- Revisa la documentaci√≥n de la API para entender el formato de respuesta actual

### Problema: Error al subir archivos grandes

**Mensaje de error:**
```
API Error (413): Request failed: Request Entity Too Large
```

**Soluci√≥n:**
- Comprime el PDF antes de subirlo
- Aumenta el timeout para la carga: `upload_document(..., timeout=1800)`
- Divide el documento en partes m√°s peque√±as si es posible

## Glosario

- **API**: Interfaz de Programaci√≥n de Aplicaciones - Permite que diferentes sistemas se comuniquen
- **Cliente**: Software que interact√∫a con un servicio remoto (en este caso, la API de Nebuia)
- **Autenticaci√≥n**: Proceso de verificar la identidad del cliente
- **Registro (Record)**: Contenedor para agrupar documentos relacionados
- **Documento**: Archivo PDF que se sube para procesamiento
- **Entidad**: Informaci√≥n extra√≠da de un documento
- **cURL**: Herramienta de l√≠nea de comandos para transferir datos con URLs
- **Callback**: Funci√≥n que se llama cuando ocurre un evento espec√≠fico
- **Tiempo de espera**: Tiempo m√°ximo que el c√≥digo esperar√° a que se complete una operaci√≥n
